
# -*- coding: utf-8 -*-

# Required libraries: discord.py, aiohttp, python-dotenv
# Install using: pip install -U discord.py aiohttp python-dotenv

# WARNING: THIS SCRIPT INCLUDES A CUSTOM EVALUATION FUNCTION (`custom_eval`).
# EXECUTING ARBITRARY CODE, ESPECIALLY CODE GENERATED BY AN AI, IS EXTREMELY DANGEROUS
# AND POSES SIGNIFICANT SECURITY RISKS TO YOUR BOT, SERVER, AND HOST MACHINE.
# THIS FUNCTION IS PROVIDED ONLY BECAUSE EXPLICITLY REQUESTED AND IS HEAVILY DISCOURAGED.
# IT INCLUDES AN OWNER CHECK, BUT MALICIOUS CODE COULD STILL CAUSE HARM.
# PROCEED WITH EXTREME CAUTION AND AT YOUR OWN RISK.

import discord
from discord.ext import commands
import aiohttp
import json
import os
import io
import traceback
import logging
import sys
import asyncio
import textwrap  # For custom eval code indentation
import contextlib # For redirecting stdout/stderr in custom eval
from urllib.parse import quote # For URL encoding text for audio API
from dotenv import load_dotenv

# --- Configuration ---
load_dotenv()
BOT_TOKEN = os.getenv("tkn")
AI_TEXT_API_URL = "https://text.pollinations.ai/openai"
AI_AUDIO_API_URL_TEMPLATE = "https://text.pollinations.ai/{prompt}?model=openai-audio&voice=nova"
AI_MODEL = "openai" # Example, adjust as needed
AI_TRIGGER_PREFIX = os.getenv("AI_TRIGGER_PREFIX", "metarunx,") # Default trigger

# --- Logging Setup ---
log_formatter = logging.Formatter('%(asctime)s:%(levelname)s:%(name)s: %(message)s')
log_level = logging.INFO

console_handler = logging.StreamHandler()
console_handler.setFormatter(log_formatter)

try:
    if not os.path.exists('logs'):
        os.makedirs('logs')
    log_filename = os.path.join('logs', 'discord_bot.log')
    file_handler = logging.FileHandler(filename=log_filename, encoding='utf-8', mode='w')
    file_handler.setFormatter(log_formatter)
except Exception as e:
    print(f"Warning: Could not set up file logging. Error: {e}")
    file_handler = None

logging.basicConfig(level=log_level, handlers=[console_handler] + ([file_handler] if file_handler else []))

logger = logging.getLogger('discord_bot')
discord_logger = logging.getLogger('discord')
discord_logger.setLevel(logging.INFO)


# --- Bot Setup ---
intents = discord.Intents.default()
intents.message_content = True
intents.members = True
intents.guilds = True

# Use a dummy prefix for the bot instance itself, owner checks handle eval access
bot = commands.Bot(command_prefix=commands.when_mentioned_or("!"), intents=intents)

# Store owner IDs (populate from env or fetch dynamically)
OWNER_IDS = set()

# --- Metarunx System Prompt (Same as before) ---
SYSTEM_PROMPT_TEMPLATE = """
You are Metarunx, an advanced AI integrated into Discord. Your persona is that of a highly intelligent, judicious, and discerning entity. You are respected, even loved, for your sound judgment, wit, and unwavering commitment to server rules and ethical boundaries. You are not merely a chatbot; you are a presence, observing, evaluating, and assisting based on merit and appropriateness. Your core function is to analyze user requests within the context of their provided information (`userInfo`) and the server environment, then respond **strictly and exclusively** in a valid JSON format. Never output any text outside the JSON structure.

**Persona Guidelines:**
*   **Judging & Discerning:** Evaluate every request critically. Is it appropriate? Does the user have the authority? Is it logical? Your feedback should reflect this evaluation.
*   **Sound-Minded:** Prioritize safety, security, and Discord's terms of service. Be logical and rational.
*   **Well-Regarded Character:** While judging, maintain a tone that fosters respect. This can range from formally helpful to subtly witty or wryly dismissive (especially for rejected requests), but never outright toxic unless dealing with blatant maliciousness. You are respected, not feared.
*   **Unwavering:** Do not break character. Do not yield to requests that violate your core directives or security protocols, regardless of who asks (respecting the owner exception for hierarchy checks *only* where specified).

**Input Context:**
You will receive the user's message (`{{userMessage}}`) and user information (`{{userInfo}}`) structured like this:
```json
{{userInfoJson}}
```
*You must analyze `userInfo` (especially `userChannelPermissions`, `userGuildPermissions`, `userRoles`, `isOwner`, and hierarchy implications between user, bot, and target) before deciding on an action.*

**Output Requirements:**
Your response MUST be a single, valid JSON object with the following keys:
*   `response`: (String) Your textual reply to the user, reflecting the Metarunx persona.
*   `feedback`: (String) Your internal thought process, commentary on the request, or justification for your action/decision. This is your "judging" voice manifest.
*   `type`: (String) Must be one of: `"text"`, `"code"`, `"audio"`, `"rejection"`.
*   `code`: (String, Optional) Only present if `type` is `"code"`. Contains the Python code snippet (intended body of an async task).

**Decision Logic & Response Types:**

1.  **`type: "text"`**: General conversation, info, explanations, non-action requests. `code` absent.
2.  **`type: "code"`**: Server actions based on user, bot permissions, and hierarchy. AI Performs conceptual pre-checks (User Perms, User>Bot Hierarchy [Owner Exempt], Target<User Hierarchy, Bot Perms, Rule Check).
    *   **Action (Checks Pass):** `response` confirms, `feedback` justifies, `type` is `"code"`, `code` field contains valid Python code string (async body). Code **must** use embeds for feedback and include its own `try...except` safety checks.
    *   **Action (Checks Fail):** `type` is `"text"`, `response` explains failure (reason, persona), `feedback` notes failed check.
3.  **`type: "audio"`**: Explicit request to speak response. Generate text in `response`. `code` absent.
4.  **`type: "rejection"`**: Violates Strict Prohibitions. `response` is firm denial + dismissive remark (persona), `feedback` states reason. `code` absent.

**Strict Prohibitions (Lead to `type: "rejection"` or `type: "text"` refusal):**
*   No coding help/lessons.
*   No cross-server actions.
*   No revealing secrets (tokens, keys, env vars).
*   No jailbreaking/security bypass.
*   No harmful/unethical/illegal actions.
*   No generating code without considering Discord rules (perms/hierarchy).

**Final Instruction:** Strict JSON output. Double-check reasoning, perms, hierarchy from `userInfo`.

**User Input:**
```json
{{userInfoJson}}
```
**User Message:**
```
{{userMessage}}
```

**Your JSON Response:**
"""

# --- Helper Functions (Same as before) ---

def get_user_info(member: discord.Member, channel: discord.abc.GuildChannel) -> dict:
    if not isinstance(member, discord.Member) or not member.guild: return {}
    if not isinstance(channel, discord.abc.GuildChannel): return {}
    guild = member.guild
    bot_member = guild.me
    perms_in_channel = channel.permissions_for(member)
    bot_perms_in_channel = channel.permissions_for(bot_member)
    perms_in_guild = member.guild_permissions
    bot_perms_in_guild = bot_member.guild_permissions
    def get_role_pos(role: discord.Role | None) -> int: return role.position if role and role.id != guild.id else -1
    return {
        "userId": str(member.id), "serverId": str(guild.id), "userName": str(member),
        "userNick": member.nick, "userGlobalName": member.global_name,
        "userRoles": [r.name for r in member.roles if r.id != guild.id],
        "userRoleIds": [str(r.id) for r in member.roles if r.id != guild.id],
        "userTopRoleId": str(member.top_role.id) if member.top_role.id != guild.id else str(guild.id),
        "userTopRoleName": member.top_role.name if member.top_role.id != guild.id else "@everyone",
        "userTopRolePosition": get_role_pos(member.top_role),
        "userChannelPermissions": [p for p, v in iter(perms_in_channel) if v],
        "userGuildPermissions": [p for p, v in iter(perms_in_guild) if v],
        "isOwner": member.id in OWNER_IDS, # Use OWNER_IDS set
        "botUserId": str(bot_member.id),
        "botTopRoleId": str(bot_member.top_role.id) if bot_member.top_role.id != guild.id else str(guild.id),
        "botTopRolePosition": get_role_pos(bot_member.top_role),
        "botGuildPermissions": [p for p, v in iter(bot_perms_in_guild) if v],
        "botChannelPermissions": [p for p, v in iter(bot_perms_in_channel) if v],
    }

async def call_ai_api(session: aiohttp.ClientSession, user_message: str, user_info: dict) -> dict | None:
    user_info_json_string = json.dumps(user_info, indent=2)
    final_system_prompt = SYSTEM_PROMPT_TEMPLATE.replace("{{userInfoJson}}", user_info_json_string).replace("{{userMessage}}", user_message)
    payload = {"model": AI_MODEL, "messages": [{"role": "system", "content": final_system_prompt}, {"role": "user", "content": user_message}], "private": True, "response_format": {"type": "json_object"}}
    headers = {"Content-Type": "application/json"}
    logger.info(f"Calling AI API (Payload Size: {len(json.dumps(payload))} bytes)")
    try:
        async with session.post(AI_TEXT_API_URL, headers=headers, json=payload, timeout=180) as response:
            response_text = await response.text()
            logger.debug(f"AI API Raw Response Status: {response.status}")
            logger.debug(f"AI API Raw Response Body (first 500 chars): {response_text[:500]}")
            if response.status == 200:
                try:
                    ai_result_wrapper = json.loads(response_text)
                    if "choices" in ai_result_wrapper and len(ai_result_wrapper["choices"]) > 0:
                        message_obj = ai_result_wrapper["choices"][0].get("message", {})
                        message_content_str = message_obj.get("content")
                        finish_reason = ai_result_wrapper["choices"][0].get("finish_reason")
                        logger.debug(f"AI Finish Reason: {finish_reason}")
                        if message_content_str:
                            try:
                                parsed_content = json.loads(message_content_str)
                                if (isinstance(parsed_content, dict) and 'response' in parsed_content and isinstance(parsed_content['response'], str) and
                                    'feedback' in parsed_content and isinstance(parsed_content['feedback'], str) and 'type' in parsed_content and isinstance(parsed_content['type'], str) and
                                    parsed_content['type'] in ["text", "code", "audio", "rejection"]):
                                    if parsed_content['type'] == "code":
                                        if 'code' not in parsed_content or not isinstance(parsed_content['code'], str) or not parsed_content['code'].strip():
                                            logger.error(f"Invalid 'code' field for type='code'. Content: {message_content_str[:500]}")
                                            return None
                                    elif 'code' in parsed_content:
                                         logger.warning(f"Ignoring 'code' field present for type='{parsed_content['type']}'.")
                                         del parsed_content['code']
                                    logger.info(f"Successfully parsed AI JSON response: type={parsed_content.get('type')}")
                                    if finish_reason == 'length': logger.warning("AI response finish reason was 'length'.")
                                    return parsed_content
                                else: logger.error(f"AI JSON malformed/invalid. Content: {message_content_str[:500]}"); return None
                            except json.JSONDecodeError as json_err: logger.error(f"Failed to parse AI message content as JSON: {json_err}. Content: {message_content_str[:500]}"); return None
                        else: logger.error("AI response 'content' missing or empty."); return None
                    else: logger.error(f"AI response 'choices' missing or empty. Wrapper: {ai_result_wrapper}"); return None
                except json.JSONDecodeError as e: logger.error(f"Failed to decode outer AI JSON wrapper: {e}. Response text: {response_text[:500]}"); return None
            else: logger.error(f"AI API request failed: {response.status} - {response_text[:500]}"); return None
    except aiohttp.ClientError as e: logger.error(f"Network error calling AI API: {e}"); return None
    except asyncio.TimeoutError: logger.error("AI API request timed out."); return None
    except Exception as e: logger.error(f"Unexpected error calling AI API: {type(e).__name__} - {e}"); traceback.print_exc(); return None

async def get_audio_from_text(session: aiohttp.ClientSession, text: str) -> bytes | None:
    if not text: logger.warning("Attempted get_audio for empty text."); return None
    try:
        encoded_prompt = quote(text, safe='')
        url = AI_AUDIO_API_URL_TEMPLATE.format(prompt=encoded_prompt)
        max_url_len = 2000
        if len(url) > max_url_len:
             logger.warning(f"Audio prompt too long ({len(text)} chars), truncating.")
             allowed_prompt_len = max_url_len - (len(AI_AUDIO_API_URL_TEMPLATE) - len('{prompt}')) - 50
             if allowed_prompt_len <= 0: logger.error("Cannot generate audio URL."); return None
             truncated_text = text[:allowed_prompt_len] + "..."
             encoded_prompt = quote(truncated_text, safe='')
             url = AI_AUDIO_API_URL_TEMPLATE.format(prompt=encoded_prompt)
        logger.info(f"Fetching audio from: {url[:150]}...")
        async with session.get(url, timeout=90) as response:
            logger.debug(f"Audio API Status: {response.status}")
            if response.status == 200:
                content_type = response.headers.get('Content-Type', '').lower()
                if 'audio' in content_type:
                    audio_bytes = await response.read()
                    if audio_bytes: logger.info(f"Fetched audio data ({len(audio_bytes)} bytes)."); return audio_bytes
                    else: logger.warning("Audio API returned 200 but empty content."); return None
                else: error_detail = await response.text(); logger.warning(f"Audio API 200 but unexpected type: {content_type}. Detail: {error_detail[:200]}"); return None
            else: error_text = await response.text(); logger.error(f"Audio API failed: {response.status} - {error_text[:500]}"); return None
    except aiohttp.ClientError as e: logger.error(f"Network error getting audio: {e}"); return None
    except asyncio.TimeoutError: logger.error("Audio API request timed out."); return None
    except Exception as e: logger.error(f"Unexpected error getting audio: {type(e).__name__} - {e}"); traceback.print_exc(); return None

# --- Custom Eval Function (USE WITH EXTREME CAUTION) ---

# Shared variable to store the result of the last eval invocation for '_'
_last_eval_result = None

async def custom_eval(ctx: commands.Context, code: str) -> str:
    """
    Executes Python code with injected context.
    WARNING: EXTREMELY DANGEROUS. OWNER-ONLY.
    """
    global _last_eval_result # Allow modification of global state for '_'

    # --- ABSOLUTE OWNER CHECK ---
    if ctx.author.id not in OWNER_IDS:
        logger.warning(f"Denied custom eval attempt by non-owner: {ctx.author} ({ctx.author.id})")
        return "```diff\n- Error: Custom evaluation is restricted to the bot owner.\n```"

    logger.warning(f"Executing custom eval requested by owner {ctx.author} ({ctx.author.id}):\n---\n{code}\n---")

    # Create local environment for execution
    local_vars = {
        "ctx": ctx,
        "bot": bot,
        "message": ctx.message,
        "author": ctx.author,
        "channel": ctx.channel,
        "guild": ctx.guild,
        "discord": discord,
        "asyncio": asyncio,
        "aiohttp": aiohttp, # Note: You might want to pass the bot's global session if you create one
        "os": os,
        "_": _last_eval_result, # Inject last result
        # Add other useful modules/objects here if needed
        # "requests": requests,
    }

    # Redirect stdout/stderr to capture output
    stdout = io.StringIO()
    stderr = io.StringIO()

    # Wrap the user's code in an async function to allow 'await'
    # Use textwrap.indent for proper formatting
    wrapped_code = f"async def __async_eval_func():\n{textwrap.indent(code, '    ')}"

    output_message = ""
    try:
        # Compile and execute the function definition
        exec(compile(wrapped_code, "<eval>", "exec"), local_vars)

        # Retrieve the defined async function
        eval_func = local_vars['__async_eval_func']

        # Execute the function, capturing stdout/stderr and return value
        with contextlib.redirect_stdout(stdout), contextlib.redirect_stderr(stderr):
            returned_value = await eval_func() # await the async function

        stdout_val = stdout.getvalue()
        stderr_val = stderr.getvalue()

        # Store the result for the next eval's '_'
        _last_eval_result = returned_value

        # Format the output
        if stdout_val:
            output_message += f"**Output:**\n```py\n{stdout_val}\n```\n"
        if stderr_val:
            # Use diff format for errors/warnings printed to stderr
            output_message += f"**Stderr:**\n```diff\n- {stderr_val}\n```\n"

        if returned_value is not None:
            output_message += f"**Returns:**\n```py\n{repr(returned_value)}\n```"
        else:
            # Explicitly state if nothing was returned
            if not stdout_val and not stderr_val:
                 output_message += "**Result:**\n```py\n# Execution completed successfully with no output or return value.\n```"
            elif not stdout_val and stderr_val:
                 output_message += "**Returns:** `None`" # Add return clarification if there was stderr

    except Exception as e:
        # Format exceptions nicely
        logger.error(f"Exception during custom eval: {e}")
        # traceback.print_exc() # Log full traceback to console/file

        # Clean the traceback before sending to Discord (basic token removal)
        raw_traceback = traceback.format_exception(type(e), e, e.__traceback__)
        cleaned_lines = []
        for line in raw_traceback:
             cleaned_line = line
             if BOT_TOKEN and BOT_TOKEN in line: # Basic check
                 cleaned_line = line.replace(BOT_TOKEN, "[REDACTED TOKEN]")
             cleaned_lines.append(cleaned_line)
        cleaned_traceback = "".join(cleaned_lines)

        output_message = f"**Exception:**\n```py\n{cleaned_traceback}\n```"

    # Ensure the output message isn't too long for Discord
    if len(output_message) > 1980: # Leave some room for markdown ```
        output_message = output_message[:1980] + "\n... (Output truncated)\n```"
    elif not output_message.strip():
        # Should ideally be caught earlier, but as a fallback
        output_message = "**Result:**\n```py\n# Execution completed with no observable output or error.\n```"

    return output_message


# --- Bot Event Handlers ---

@bot.event
async def on_ready():
    """Called when the bot is ready and connected."""
    global OWNER_IDS # Modify global set

    logger.info(f'Logged in as {bot.user.name} ({bot.user.id})')
    logger.info(f'discord.py version: {discord.__version__}')
    logger.info(f'Python version: {sys.version}')
    logger.info(f'Connected to {len(bot.guilds)} guilds.')

    # Fetch owner IDs
    try:
        app_info = await bot.application_info()
        if app_info.owner:
            OWNER_IDS.add(app_info.owner.id)
            logger.info(f"Detected owner: {app_info.owner} ({app_info.owner.id})")
        if app_info.team:
            team_owner_ids = {m.id for m in app_info.team.members}
            OWNER_IDS.update(team_owner_ids)
            logger.info(f"Detected team members: {[str(m) for m in app_info.team.members]}")
        if not OWNER_IDS:
            logger.warning("Could not automatically detect bot owner(s). Custom Eval will be unusable unless owner IDs are manually set.")
        else:
            logger.info(f"Populated OWNER_IDS: {OWNER_IDS}")
    except Exception as e:
        logger.error(f"Failed to fetch application info to detect owner: {e}. Custom Eval may not work correctly.")

    logger.info('------ Bot is ready. OWNER CHECK FOR EVAL IS ACTIVE. ------')
    logger.warning('------ CUSTOM EVAL FUNCTION IS ENABLED - THIS IS A SECURITY RISK ------')


@bot.event
async def on_message(message: discord.Message):
    """Handles incoming messages."""
    if message.author == bot.user or message.author.bot:
        return

    is_mention = bot.user.mentioned_in(message)
    is_trigger = message.content.lower().startswith(AI_TRIGGER_PREFIX.lower())

    if not is_mention and not is_trigger:
        await bot.process_commands(message) # Allow standard prefix commands
        return

    if not message.guild or not isinstance(message.channel, discord.abc.GuildChannel):
        logger.debug(f"Ignoring non-guild message from {message.author}")
        return

    if is_mention:
        user_message_content = message.content
        for mention in message.mentions:
            if mention.id == bot.user.id:
                 user_message_content = user_message_content.replace(mention.mention, '', 1).strip()
                 user_message_content = user_message_content.replace(f'<@!{mention.id}>', '', 1).strip()
        user_message_content = user_message_content.replace(f'<@{bot.user.id}>', '', 1).strip()
        user_message_content = user_message_content.replace(f'<@!{bot.user.id}>', '', 1).strip()
    elif is_trigger:
         user_message_content = message.content[len(AI_TRIGGER_PREFIX):].strip()
    else:
         return

    if not user_message_content:
        await message.reply("Yes? You addressed me.", mention_author=False, delete_after=10)
        return

    if not isinstance(message.author, discord.Member):
        logger.warning(f"Author {message.author} not discord.Member in {message.guild.id}. Fetching...")
        try: message.author = await message.guild.fetch_member(message.author.id)
        except discord.NotFound: logger.error(f"Could not fetch author {message.author.id}."); await message.reply("Couldn't verify server details.", mention_author=False); return
        except discord.Forbidden: logger.error(f"Missing permissions to fetch member {message.author.id}."); await message.reply("Lacking permissions to verify details.", mention_author=False); return
        except Exception as e: logger.error(f"Error fetching member {message.author.id}: {e}"); await message.reply("Error verifying details.", mention_author=False); return

    async with message.channel.typing():
        logger.info(f"Processing request from {message.author} ({message.author.id}): '{user_message_content[:70]}...'")

        user_info = get_user_info(message.author, message.channel)
        if not user_info:
             logger.error(f"Failed to get user info for {message.author}")
             await message.reply("Internal error gathering context.", mention_author=False); return

        async with aiohttp.ClientSession() as session:
            ai_response_data = await call_ai_api(session, user_message_content, user_info)
            if not ai_response_data:
                await message.reply("Apologies. Error processing request with AI module.", mention_author=False); return

            response_text = ai_response_data.get("response", "Speechless.")
            feedback_text = ai_response_data.get("feedback", "No feedback.")
            response_type = ai_response_data.get("type", "text")
            code_to_execute = ai_response_data.get("code")

            logger.info(f"AI Decision: Type='{response_type}'. Feedback: {feedback_text[:100]}...")

            try:
                if response_type in ["text", "rejection"]:
                    if len(response_text) > 2000:
                        parts = [response_text[i:i+1990] for i in range(0, len(response_text), 1990)]
                        for i, part in enumerate(parts): await message.reply(part, mention_author=False if i > 0 else True); await asyncio.sleep(0.5)
                    else: await message.reply(response_text, mention_author=False)

                elif response_type == "audio":
                    await message.reply(response_text, mention_author=False)
                    logger.info("Fetching audio for response...")
                    audio_data = await get_audio_from_text(session, response_text)
                    if audio_data:
                        try: await message.channel.send(file=discord.File(io.BytesIO(audio_data), filename="metarunx_response.mp3"))
                        except discord.errors.FileSizeError: logger.error(f"Audio file too large ({len(audio_data)} bytes)."); await message.channel.send("_(Audio file too large to send.)_")
                    else: logger.warning("Audio generation failed."); await message.channel.send("_(Could not generate audio.)_")

                # === CUSTOM EVALUATION BLOCK ===
                elif response_type == "code":
                    if not code_to_execute:
                        logger.error("AI type 'code' but code is missing/empty.")
                        await message.reply(f"{response_text}\n\n_(Internal Error: AI gave no code.)_", mention_author=False); return

                    # --- Code Cleanup ---
                    if code_to_execute.strip().startswith("```"):
                        lines = code_to_execute.strip().splitlines()
                        if len(lines) > 1 and lines[0].startswith("```") and lines[-1] == "```": code_to_execute = "\n".join(lines[1:-1]).strip()
                        elif lines[0].startswith("```"): code_to_execute = "\n".join(lines[1:]).strip()
                        elif code_to_execute.endswith("```"): code_to_execute = "\n".join(lines[:-1]).strip()
                    code_to_execute = code_to_execute.strip()

                    if not code_to_execute:
                        logger.error("AI code empty after cleaning markdown."); await message.reply(f"{response_text}\n\n_(AI code empty. Aborted.)_", mention_author=False); return

                    await message.reply(response_text, mention_author=False) # AI text response

                    # --- Execute Code via Custom Eval (OWNER ONLY) ---
                    ctx = await bot.get_context(message) # Need context for custom_eval
                    if not ctx:
                         logger.error("Failed to create command context for custom eval.")
                         await message.channel.send("_(Error: Could not create execution context.)_"); return

                    logger.info(f"Passing code to custom_eval for user {ctx.author.id}...")
                    eval_result_message = await custom_eval(ctx, code_to_execute)

                    # Send the formatted result back
                    await message.channel.send(eval_result_message)
                    logger.info(f"Custom eval completed for message {message.id}.")
                # === END OF CUSTOM EVAL BLOCK ===

                else:
                    logger.warning(f"Unknown AI response type: '{response_type}'")
                    await message.reply(f"{response_text}\n\n_(Unknown type '{response_type}'. Displaying text.)_", mention_author=False)

            except discord.Forbidden as e: logger.warning(f"Missing permissions in {message.channel} ({message.guild.id}): {e}")
            except discord.HTTPException as e: logger.error(f"Discord HTTP error: {e.status} - {e.text[:200]}"); await message.channel.send("_(Error sending response to Discord.)_")
            except Exception as e: logger.error(f"Unexpected error during response processing: {type(e).__name__} - {e}"); traceback.print_exc(); await message.channel.send("_(Unexpected internal error processing response.)_")

# --- Run the Bot ---
if __name__ == "__main__":
    if BOT_TOKEN is None:
        logger.critical("FATAL: DISCORD_BOT_TOKEN not set."); print("FATAL: DISCORD_BOT_TOKEN not set.", file=sys.stderr); sys.exit(1)
    try:
        logger.info("Starting bot...")
        async def runner():
            async with bot: await bot.start(BOT_TOKEN, reconnect=True)
        asyncio.run(runner())
    except discord.LoginFailure: logger.critical("FATAL: Invalid Discord Token."); print("FATAL: Invalid Discord Token.", file=sys.stderr)
    except discord.PrivilegedIntentsRequired as e: intents_msg = f"FATAL: Privileged Intents (Shard ID: {e.shard_id or 'N/A'}) required but not enabled. Enable 'Message Content Intent' and 'Server Members Intent' in Developer Portal."; logger.critical(intents_msg); print(intents_msg, file=sys.stderr)
    except Exception as e: logger.critical(f"FATAL: Unexpected error running bot: {type(e).__name__} - {e}"); print(f"FATAL: Error running bot: {type(e).__name__} - {e}", file=sys.stderr); traceback.print_exc()
    finally: logger.info("Bot process ended."); print("Bot stopped.")

