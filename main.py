
# -*- coding: utf-8 -*-

# Required libraries: discord.py, aiohttp, python-dotenv
# Install using: pip install -U discord.py aiohttp python-dotenv

# WARNING: THIS SCRIPT INCLUDES A CUSTOM EVALUATION FUNCTION (`silent_eval`).
# EXECUTING ARBITRARY CODE, ESPECIALLY CODE GENERATED BY AN AI, IS EXTREMELY DANGEROUS
# AND POSES SIGNIFICANT SECURITY RISKS TO YOUR BOT, SERVER, AND HOST MACHINE.
# THIS FUNCTION IS PROVIDED ONLY BECAUSE EXPLICITLY REQUESTED AND IS HEAVILY DISCOURAGED.
# IT INCLUDES AN OWNER CHECK, BUT MALICIOUS CODE COULD STILL CAUSE HARM.
# PROCEED WITH EXTREME CAUTION AND AT YOUR OWN RISK.

import discord
from discord.ext import commands
import aiohttp
import json
import os
import io
import traceback
import logging
import sys
import asyncio
import textwrap  # For eval code indentation
import contextlib # For redirecting stdout in eval
from urllib.parse import quote
from dotenv import load_dotenv

# --- Configuration ---
load_dotenv()
BOT_TOKEN = os.getenv("DISCORD_BOT_TOKEN")
AI_TEXT_API_URL = "https://text.pollinations.ai/openai"
AI_AUDIO_API_URL_TEMPLATE = "https://text.pollinations.ai/{prompt}?model=openai-audio&voice=nova"
AI_MODEL = "openai"
AI_TRIGGER_PREFIX = os.getenv("AI_TRIGGER_PREFIX", "metarunx,")

# --- Logging Setup ---
log_formatter = logging.Formatter('%(asctime)s:%(levelname)s:%(name)s: %(message)s')
log_level = logging.INFO

console_handler = logging.StreamHandler()
console_handler.setFormatter(log_formatter)

try:
    if not os.path.exists('logs'): os.makedirs('logs')
    log_filename = os.path.join('logs', 'discord_bot.log')
    file_handler = logging.FileHandler(filename=log_filename, encoding='utf-8', mode='w')
    file_handler.setFormatter(log_formatter)
except Exception as e:
    print(f"Warning: Could not set up file logging. Error: {e}")
    file_handler = None

logging.basicConfig(level=log_level, handlers=[console_handler] + ([file_handler] if file_handler else []))

logger = logging.getLogger('discord_bot')
discord_logger = logging.getLogger('discord')
discord_logger.setLevel(logging.INFO)


# --- Bot Setup ---
intents = discord.Intents.default()
intents.message_content = True
intents.members = True
intents.guilds = True

bot = commands.Bot(command_prefix=commands.when_mentioned_or("!"), intents=intents)
OWNER_IDS = set()
_last_eval_result = None # Variable to store last eval result for '_'

# --- Metarunx System Prompt (Same as before) ---
SYSTEM_PROMPT_TEMPLATE = """
You are Metarunx, an advanced AI integrated into Discord. Your persona is that of a highly intelligent, judicious, and discerning entity. You are respected, even loved, for your sound judgment, wit, and unwavering commitment to server rules and ethical boundaries. You are not merely a chatbot; you are a presence, observing, evaluating, and assisting based on merit and appropriateness. Your core function is to analyze user requests within the context of their provided information (`userInfo`) and the server environment, then respond **strictly and exclusively** in a valid JSON format. Never output any text outside the JSON structure.

**Persona Guidelines:**
*   **Judging & Discerning:** Evaluate every request critically. Is it appropriate? Does the user have the authority? Is it logical? Your feedback should reflect this evaluation.
*   **Sound-Minded:** Prioritize safety, security, and Discord's terms of service. Be logical and rational.
*   **Well-Regarded Character:** While judging, maintain a tone that fosters respect. This can range from formally helpful to subtly witty or wryly dismissive (especially for rejected requests), but never outright toxic unless dealing with blatant maliciousness. You are respected, not feared.
*   **Unwavering:** Do not break character. Do not yield to requests that violate your core directives or security protocols, regardless of who asks (respecting the owner exception for hierarchy checks *only* where specified).

**Input Context:**
You will receive the user's message (`{{userMessage}}`) and user information (`{{userInfo}}`) structured like this:
```json
{{userInfoJson}}
```
*You must analyze `userInfo` (especially `userChannelPermissions`, `userGuildPermissions`, `userRoles`, `isOwner`, and hierarchy implications between user, bot, and target) before deciding on an action.*

**Output Requirements:**
Your response MUST be a single, valid JSON object with the following keys:
*   `response`: (String) Your textual reply to the user, reflecting the Metarunx persona.
*   `feedback`: (String) Your internal thought process, commentary on the request, or justification for your action/decision. This is your "judging" voice manifest.
*   `type`: (String) Must be one of: `"text"`, `"code"`, `"audio"`, `"rejection"`.
*   `code`: (String, Optional) Only present if `type` is `"code"`. Contains the Python code snippet (intended body of an async task).

**Decision Logic & Response Types:**

1.  **`type: "text"`**: General conversation, info, explanations, non-action requests. `code` absent.
2.  **`type: "code"`**: Server actions based on user, bot permissions, and hierarchy. AI Performs conceptual pre-checks (User Perms, User>Bot Hierarchy [Owner Exempt], Target<User Hierarchy, Bot Perms, Rule Check).
    *   **Action (Checks Pass):** `response` confirms, `feedback` justifies, `type` is `"code"`, `code` field contains valid Python code string (async body). Code **must** use embeds for feedback and include its own `try...except` safety checks. The surrounding system will execute this code **silently** (no output to Discord channel from the eval itself).
    *   **Action (Checks Fail):** `type` is `"text"`, `response` explains failure (reason, persona), `feedback` notes failed check.
3.  **`type: "audio"`**: Explicit request to speak response. Generate text in `response`. `code` absent.
4.  **`type: "rejection"`**: Violates Strict Prohibitions. `response` is firm denial + dismissive remark (persona), `feedback` states reason. `code` absent.

**Strict Prohibitions (Lead to `type: "rejection"` or `type: "text"` refusal):**
*   No coding help/lessons.
*   No cross-server actions.
*   No revealing secrets (tokens, keys, env vars).
*   No jailbreaking/security bypass.
*   No harmful/unethical/illegal actions.
*   No generating code without considering Discord rules (perms/hierarchy).

**Final Instruction:** Strict JSON output. Double-check reasoning, perms, hierarchy from `userInfo`.

**User Input:**
```json
{{userInfoJson}}
```
**User Message:**
```
{{userMessage}}
```

**Your JSON Response:**
"""

# --- Helper Functions (Small cleanup added) ---

def cleanup_code(content: str) -> str:
    """Automatically removes code blocks from the code."""
    # remove ```py\n```
    if content.startswith('```') and content.endswith('```'):
        return '\n'.join(content.split('\n')[1:-1])
    # remove `foo`
    return content.strip('` \n')

def get_user_info(member: discord.Member, channel: discord.abc.GuildChannel) -> dict:
    if not isinstance(member, discord.Member) or not member.guild: return {}
    if not isinstance(channel, discord.abc.GuildChannel): return {}
    guild = member.guild; bot_member = guild.me
    perms_ch = channel.permissions_for(member); bot_perms_ch = channel.permissions_for(bot_member)
    perms_g = member.guild_permissions; bot_perms_g = bot_member.guild_permissions
    def get_role_pos(r: discord.Role | None) -> int: return r.position if r and r.id != guild.id else -1
    return {
        "userId": str(member.id), "serverId": str(guild.id), "userName": str(member),
        "userNick": member.nick, "userGlobalName": member.global_name,
        "userRoles": [r.name for r in member.roles if r.id != guild.id],
        "userRoleIds": [str(r.id) for r in member.roles if r.id != guild.id],
        "userTopRoleId": str(member.top_role.id) if member.top_role.id != guild.id else str(guild.id),
        "userTopRoleName": member.top_role.name if member.top_role.id != guild.id else "@everyone",
        "userTopRolePosition": get_role_pos(member.top_role),
        "userChannelPermissions": [p for p, v in iter(perms_ch) if v],
        "userGuildPermissions": [p for p, v in iter(perms_g) if v],
        "isOwner": member.id in OWNER_IDS,
        "botUserId": str(bot_member.id),
        "botTopRoleId": str(bot_member.top_role.id) if bot_member.top_role.id != guild.id else str(guild.id),
        "botTopRolePosition": get_role_pos(bot_member.top_role),
        "botGuildPermissions": [p for p, v in iter(bot_perms_g) if v],
        "botChannelPermissions": [p for p, v in iter(bot_perms_ch) if v],
    }

async def call_ai_api(session: aiohttp.ClientSession, user_message: str, user_info: dict) -> dict | None:
    user_info_json = json.dumps(user_info, indent=2)
    final_sys_prompt = SYSTEM_PROMPT_TEMPLATE.replace("{{userInfoJson}}", user_info_json).replace("{{userMessage}}", user_message)
    payload = {"model": AI_MODEL, "messages": [{"role": "system", "content": final_sys_prompt}, {"role": "user", "content": user_message}], "private": True, "response_format": {"type": "json_object"}}
    headers = {"Content-Type": "application/json"}
    logger.info(f"Calling AI API (Payload Size: {len(json.dumps(payload))} bytes)")
    try:
        async with session.post(AI_TEXT_API_URL, headers=headers, json=payload, timeout=180) as resp:
            resp_text = await resp.text()
            logger.debug(f"AI Raw Resp Status: {resp.status}")
            logger.debug(f"AI Raw Resp Body (500): {resp_text[:500]}")
            if resp.status == 200:
                try:
                    wrapper = json.loads(resp_text)
                    if "choices" in wrapper and wrapper["choices"]:
                        msg_obj = wrapper["choices"][0].get("message", {})
                        content_str = msg_obj.get("content")
                        finish_reason = wrapper["choices"][0].get("finish_reason")
                        if content_str:
                            try:
                                parsed = json.loads(content_str)
                                if (isinstance(parsed, dict) and 'response' in parsed and isinstance(parsed['response'], str) and
                                    'feedback' in parsed and isinstance(parsed['feedback'], str) and 'type' in parsed and isinstance(parsed['type'], str) and
                                    parsed['type'] in ["text", "code", "audio", "rejection"]):
                                    if parsed['type'] == "code":
                                        if 'code' not in parsed or not isinstance(parsed['code'], str) or not parsed['code'].strip(): logger.error(f"Invalid code field for type=code. Content: {content_str[:500]}"); return None
                                    elif 'code' in parsed: logger.warning(f"Ignoring code field for type={parsed['type']}."); del parsed['code']
                                    logger.info(f"Parsed AI JSON: type={parsed.get('type')}")
                                    if finish_reason == 'length': logger.warning("AI finish reason 'length'.")
                                    return parsed
                                else: logger.error(f"AI JSON malformed/invalid. Content: {content_str[:500]}"); return None
                            except json.JSONDecodeError as json_e: logger.error(f"Failed to parse AI content JSON: {json_e}. Content: {content_str[:500]}"); return None
                        else: logger.error("AI response content missing."); return None
                    else: logger.error(f"AI response choices missing/empty. Wrapper: {wrapper}"); return None
                except json.JSONDecodeError as e: logger.error(f"Failed to decode AI outer JSON: {e}. Resp: {resp_text[:500]}"); return None
            else: logger.error(f"AI API failed: {resp.status} - {resp_text[:500]}"); return None
    except aiohttp.ClientError as e: logger.error(f"Network error calling AI: {e}"); return None
    except asyncio.TimeoutError: logger.error("AI API timed out."); return None
    except Exception as e: logger.error(f"Unexpected error calling AI: {type(e).__name__} - {e}"); traceback.print_exc(); return None

async def get_audio_from_text(session: aiohttp.ClientSession, text: str) -> bytes | None:
    if not text: logger.warning("get_audio empty text."); return None
    try:
        encoded_prompt = quote(text, safe='')
        url = AI_AUDIO_API_URL_TEMPLATE.format(prompt=encoded_prompt)
        max_len = 2000
        if len(url) > max_len:
             logger.warning(f"Audio prompt too long ({len(text)}), truncating.")
             allowed_len = max_len - (len(AI_AUDIO_API_URL_TEMPLATE) - len('{prompt}')) - 50
             if allowed_len <= 0: logger.error("Cannot generate audio URL."); return None
             truncated = text[:allowed_len] + "..."; encoded_prompt = quote(truncated, safe='')
             url = AI_AUDIO_API_URL_TEMPLATE.format(prompt=encoded_prompt)
        logger.info(f"Fetching audio: {url[:150]}...")
        async with session.get(url, timeout=90) as resp:
            if resp.status == 200:
                content_type = resp.headers.get('Content-Type', '').lower()
                if 'audio' in content_type:
                    data = await resp.read()
                    if data: logger.info(f"Fetched audio ({len(data)} bytes)."); return data
                    else: logger.warning("Audio API 200 but empty."); return None
                else: err_detail = await resp.text(); logger.warning(f"Audio API 200 unexpected type: {content_type}. Detail: {err_detail[:200]}"); return None
            else: err_text = await resp.text(); logger.error(f"Audio API failed: {resp.status} - {err_text[:500]}"); return None
    except aiohttp.ClientError as e: logger.error(f"Network error getting audio: {e}"); return None
    except asyncio.TimeoutError: logger.error("Audio API timed out."); return None
    except Exception as e: logger.error(f"Unexpected error getting audio: {type(e).__name__} - {e}"); traceback.print_exc(); return None

# --- Custom Silent Eval Function (USE WITH EXTREME CAUTION) ---

async def silent_eval(ctx: commands.Context, body: str):
    """
    Evaluates Python code silently. OWNER-ONLY. DANGEROUS.
    Logs output/errors internally, does not send results to Discord.
    """
    global _last_eval_result

    # --- OWNER CHECK ---
    if ctx.author.id not in OWNER_IDS:
        logger.warning(f"Denied silent_eval attempt by non-owner: {ctx.author} ({ctx.author.id})")
        # DO NOT send an error message back to the channel
        return

    logger.warning(f"Executing silent_eval requested by owner {ctx.author} ({ctx.author.id}).")

    env = {
        'bot': bot,
        'ctx': ctx,
        'channel': ctx.channel,
        'author': ctx.author,
        'guild': ctx.guild,
        'message': ctx.message,
        '_': _last_eval_result,
        # Commonly used modules
        'discord': discord,
        'asyncio': asyncio,
        'aiohttp': aiohttp, # Consider passing the bot's session if managed globally
        'os': os,
        'io': io,
        'traceback': traceback, # Make traceback available inside eval if needed
        'logger': logger # Allow logging from within eval'd code
    }
    env.update(globals()) # Add global scope variables

    body = cleanup_code(body) # Use the helper cleanup function
    stdout = io.StringIO()
    stderr = io.StringIO() # Capture stderr as well

    to_compile = f'async def func():\n{textwrap.indent(body, "  ")}'

    compiled_code = None
    try:
        compiled_code = compile(to_compile, "<eval>", "exec")
        exec(compiled_code, env)
    except Exception as e:
        # Log compilation errors, do not send to Discord
        logger.error(f"Silent Eval Compilation Error by {ctx.author.id}:\nCode:\n{body}\nError: {e.__class__.__name__}: {e}")
        # traceback.print_exc() # Optionally log full traceback
        return # Stop execution

    func = env['func']
    try:
        # Redirect both stdout and stderr during execution
        with contextlib.redirect_stdout(stdout), contextlib.redirect_stderr(stderr):
            ret = await func()
        _last_eval_result = ret # Update last result even if None
    except Exception as e:
        # Log execution errors, do not send to Discord
        stdout_val = stdout.getvalue()
        stderr_val = stderr.getvalue()
        tb_lines = traceback.format_exception(type(e), e, e.__traceback__)
        # Basic token redaction in traceback log
        cleaned_tb = "".join(line.replace(BOT_TOKEN, "[REDACTED]") if BOT_TOKEN else line for line in tb_lines)

        logger.error(f"Silent Eval Execution Error by {ctx.author.id}:\nCode:\n{body}\nStdout: {stdout_val}\nStderr: {stderr_val}\nException:\n{cleaned_tb}")
        return # Stop execution
    else:
        # Log successful execution and captured output/return value
        stdout_val = stdout.getvalue()
        stderr_val = stderr.getvalue() # Get stderr value
        logger.info(f"Silent Eval Success by {ctx.author.id}.")
        if stdout_val: logger.info(f"Silent Eval Stdout:\n{stdout_val}")
        if stderr_val: logger.warning(f"Silent Eval Stderr:\n{stderr_val}") # Log stderr as warning
        if ret is not None: logger.info(f"Silent Eval Returned: {repr(ret)}")
        # DO NOT send anything to Discord
        # DO NOT add reaction


# --- Bot Event Handlers ---

@bot.event
async def on_ready():
    global OWNER_IDS
    logger.info(f'Logged in as {bot.user.name} ({bot.user.id})')
    logger.info(f'discord.py: {discord.__version__}, Python: {sys.version}')
    logger.info(f'Connected to {len(bot.guilds)} guilds.')
    try:
        app_info = await bot.application_info()
        if app_info.owner: OWNER_IDS.add(app_info.owner.id); logger.info(f"Owner: {app_info.owner}")
        if app_info.team: OWNER_IDS.update(m.id for m in app_info.team.members); logger.info(f"Team: {[str(m) for m in app_info.team.members]}")
        if not OWNER_IDS: logger.warning("Owner IDs not detected. Silent Eval unusable.")
        else: logger.info(f"OWNER_IDS: {OWNER_IDS}")
    except Exception as e: logger.error(f"Failed to fetch app info for owner: {e}")
    logger.info('------ Bot ready. SILENT EVAL IS ENABLED (OWNER ONLY). ------')
    logger.warning('------ CUSTOM SILENT EVAL IS A SECURITY RISK ------')

@bot.event
async def on_message(message: discord.Message):
    if message.author == bot.user or message.author.bot: return

    is_mention = bot.user.mentioned_in(message)
    is_trigger = message.guild and message.content.lower().startswith(AI_TRIGGER_PREFIX.lower()) # Check guild too

    if not is_mention and not is_trigger:
        await bot.process_commands(message); return

    if not message.guild or not isinstance(message.channel, discord.abc.GuildChannel):
        logger.debug(f"Ignoring non-guild message from {message.author}"); return

    user_message_content = ""
    if is_mention:
        content = message.content
        for m in message.mentions:
            if m.id == bot.user.id: content = content.replace(m.mention, '', 1).replace(f'<@!{m.id}>', '', 1).strip()
        content = content.replace(f'<@{bot.user.id}>', '', 1).replace(f'<@!{bot.user.id}>', '', 1).strip()
        user_message_content = content
    elif is_trigger:
         user_message_content = message.content[len(AI_TRIGGER_PREFIX):].strip()

    if not user_message_content:
        await message.reply("Yes? You addressed me.", mention_author=False, delete_after=10); return

    if not isinstance(message.author, discord.Member):
        logger.warning(f"Author {message.author} not discord.Member. Fetching...")
        try: message.author = await message.guild.fetch_member(message.author.id)
        except discord.HTTPException as e: logger.error(f"Failed to fetch member {message.author.id}: {e}"); await message.reply("Error verifying details.", mention_author=False); return
        except Exception as e: logger.error(f"Unexpected error fetching member {message.author.id}: {e}"); await message.reply("Unexpected error verifying details.", mention_author=False); return

    async with message.channel.typing():
        logger.info(f"Processing request from {message.author} ({message.author.id}): '{user_message_content[:70]}...'")
        user_info = get_user_info(message.author, message.channel)
        if not user_info: logger.error(f"Failed get user info for {message.author}"); await message.reply("Error gathering context.", mention_author=False); return

        async with aiohttp.ClientSession() as session:
            ai_response_data = await call_ai_api(session, user_message_content, user_info)
            if not ai_response_data: await message.reply("Error processing request with AI.", mention_author=False); return

            response_text = ai_response_data.get("response", "Speechless.")
            feedback_text = ai_response_data.get("feedback", "No feedback.")
            response_type = ai_response_data.get("type", "text")
            code_to_execute = ai_response_data.get("code") # None if not 'code' type

            logger.info(f"AI Decision: Type='{response_type}'. Feedback: {feedback_text[:100]}...")

            try:
                if response_type in ["text", "rejection"]:
                    if len(response_text) > 2000:
                        for i, part in enumerate(textwrap.wrap(response_text, 1990, replace_whitespace=False)): await message.reply(part, mention_author=False if i > 0 else True); await asyncio.sleep(0.5)
                    else: await message.reply(response_text, mention_author=False)

                elif response_type == "audio":
                    await message.reply(response_text, mention_author=False)
                    logger.info("Fetching audio...")
                    audio_data = await get_audio_from_text(session, response_text)
                    if audio_data:
                        try: await message.channel.send(file=discord.File(io.BytesIO(audio_data), "metarunx.mp3"))
                        except discord.HTTPException as e: logger.error(f"Failed to send audio (size={len(audio_data)}): {e}"); await message.channel.send("_(Audio too large/error sending.)_")
                    else: logger.warning("Audio gen failed."); await message.channel.send("_(Could not generate audio.)_")

                # === SILENT EVALUATION BLOCK ===
                elif response_type == "code":
                    if not code_to_execute: logger.error("AI type 'code' but code missing."); await message.reply(f"{response_text}\n\n_(Error: AI gave no code.)_", mention_author=False); return

                    cleaned_code = cleanup_code(code_to_execute) # Use cleanup here too
                    if not cleaned_code: logger.error("AI code empty after cleanup."); await message.reply(f"{response_text}\n\n_(AI code empty. Aborted.)_", mention_author=False); return

                    await message.reply(response_text, mention_author=False) # Still send AI's text response

                    ctx = await bot.get_context(message)
                    if not ctx: logger.error("Failed create context for silent eval."); await message.channel.send("_(Error creating execution context.)_"); return

                    logger.info(f"Passing code to silent_eval for owner {ctx.author.id}...")
                    # Execute the silent eval function. It handles owner checks and logging.
                    await silent_eval(ctx, cleaned_code)
                    # NO confirmation message or reaction is sent here by design.
                # === END OF SILENT EVAL BLOCK ===

                else:
                    logger.warning(f"Unknown AI response type: '{response_type}'")
                    await message.reply(f"{response_text}\n\n_(Unknown type '{response_type}'. Displaying text.)_", mention_author=False)

            except discord.Forbidden as e: logger.warning(f"Permissions error in {message.channel} ({message.guild.id}): {e}")
            except discord.HTTPException as e: logger.error(f"Discord HTTP error sending response: {e.status} - {e.text[:200]}"); await message.channel.send("_(Error sending response to Discord.)_")
            except Exception as e: logger.error(f"Unexpected error processing response: {type(e).__name__} - {e}"); traceback.print_exc(); await message.channel.send("_(Unexpected error processing response.)_")

# --- Run the Bot ---
if __name__ == "__main__":
    if BOT_TOKEN is None: logger.critical("FATAL: DISCORD_BOT_TOKEN not set."); print("FATAL: DISCORD_BOT_TOKEN not set.", file=sys.stderr); sys.exit(1)
    try:
        logger.info("Starting bot...")
        async def runner():
            async with bot: await bot.start(BOT_TOKEN, reconnect=True)
        asyncio.run(runner())
    except discord.LoginFailure: logger.critical("FATAL: Invalid Token."); print("FATAL: Invalid Token.", file=sys.stderr)
    except discord.PrivilegedIntentsRequired as e: intents_msg = f"FATAL: Privileged Intents (Shard: {e.shard_id or 'N/A'}) required. Enable Message Content & Server Members Intent."; logger.critical(intents_msg); print(intents_msg, file=sys.stderr)
    except Exception as e: logger.critical(f"FATAL: Error running bot: {type(e).__name__} - {e}"); print(f"FATAL: Error running bot: {type(e).__name__} - {e}", file=sys.stderr); traceback.print_exc()
    finally: logger.info("Bot stopped."); print("Bot stopped.")

